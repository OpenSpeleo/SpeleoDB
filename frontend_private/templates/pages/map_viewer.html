{% extends "base_private.html" %}
{% load static i18n compress%}

{% block extra_css %}
<link href='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css' rel='stylesheet' />
<style>
    /* Custom scrollbar for project list */
    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(51, 65, 85, 0.5); /* slate-700 with opacity */
        border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgba(148, 163, 184, 0.8); /* slate-400 with opacity */
        border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgba(203, 213, 225, 0.9); /* slate-300 with opacity */
    }
    
    /* Loading spinner overlay */
    .loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.9); /* slate-900 with opacity */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        backdrop-filter: blur(4px);
        transition: opacity 0.5s ease-out, visibility 0.5s ease-out;
    }
    
    .loading-overlay.hide {
        opacity: 0;
        visibility: hidden;
    }
    
    /* Material Design spinner */
    .loading-spinner {
        width: 56px;
        height: 56px;
        border: 4px solid rgba(56, 189, 248, 0.2); /* sky-400 with opacity */
        border-left: 4px solid #38bdf8; /* sky-400 */
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 24px;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    .loading-text {
        color: #f1f5f9; /* slate-100 */
        font-size: 16px;
        font-weight: 500;
        margin-bottom: 8px;
    }
    
    .loading-subtext {
        color: #94a3b8; /* slate-400 */
        font-size: 14px;
        text-align: center;
        max-width: 300px;
        line-height: 1.4;
    }
    
    /* Material Design Toggle Switch */
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
        margin-left: auto;
        flex-shrink: 0;
    }
    
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(100, 116, 139, 0.5); /* slate-500 with opacity */
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 12px;
        box-shadow: inset 0 0 0 2px transparent;
    }
    
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 2px;
        bottom: 2px;
        background-color: white;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .toggle-switch input:checked + .toggle-slider {
        background-color: #38bdf8; /* sky-400 */
        box-shadow: inset 0 0 0 2px #0284c7; /* sky-600 */
    }
    
    .toggle-switch input:checked + .toggle-slider:before {
        transform: translateX(20px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .toggle-switch input:focus + .toggle-slider {
        box-shadow: inset 0 0 0 2px #0284c7, 0 0 0 3px rgba(56, 189, 248, 0.2); /* sky-600 and sky-400 with opacity */
    }
    
    /* Enhanced project button styling */
    .project-button {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        text-left: left;
        padding: 12px;
        border-radius: 8px;
        background: rgba(51, 65, 85, 0.8); /* slate-700 with opacity */
        border: 1px solid rgba(100, 116, 139, 0.3); /* slate-500 with opacity */
        color: white;
        font-size: 14px;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(8px);
        cursor: pointer;
    }
    
    .project-button:hover {
        background: rgba(71, 85, 105, 0.9); /* slate-600 with opacity */
        border-color: rgba(148, 163, 184, 0.5); /* slate-400 with opacity */
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }
    
    .project-button-content {
        display: flex;
        align-items: center;
        min-width: 0;
        flex: 1;
        margin-right: 12px;
    }
    
    .project-color-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        flex-shrink: 0;
        margin-right: 8px;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .project-name {
        font-weight: 500;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        line-height: 1.2;
    }
</style>
{% endblock extra_css %}

{% block content %}
<main class="grow">
    <div class="px-4 sm:px-6 lg:px-8 py-8 w-full max-w-9xl mx-auto">

        <!-- Page header -->
        <div class="sm:flex sm:justify-between sm:items-center mb-8">

            <!-- Left: Title -->
            <div class="mb-4 sm:mb-0">
                <h1 class="text-2xl md:text-3xl text-slate-100 font-bold">
                    Survey Viewer
                </h1>
            </div>

            <!-- Right: Actions -->
            <div class="grid grid-flow-col sm:auto-cols-max justify-start sm:justify-end gap-2">

                <!-- New button -->
                <button class="btn bg-sky-500 hover:bg-sky-600 text-white">
                    <svg class="w-4 h-4 stroke-current fill-none shrink-0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="3.5 3.51 17 16.97">
                        <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                    <a id="btn_release_all_locks" class="hidden xs:block ml-2">Refresh all my Projects</a>
                </button>

            </div>

        </div>

        <!-- Table -->
        <div class="bg-slate-800 shadow-lg rounded-sm border border-slate-200 border-slate-700 relative">
            <div id='map' style='width: 100%; min-height: 600px; display: block;'></div>
            
            <!-- Loading Overlay -->
            <div id="loading-overlay" class="loading-overlay">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading Survey Data</div>
                <div class="loading-subtext">Downloading and processing GeoJSON data from projects...</div>
            </div>
            
            <!-- Floating Project List Panel -->
            <div id="project-panel" class="absolute top-4 left-4 bg-slate-800/95 backdrop-blur-sm border-2 border-gray-500 rounded-lg shadow-xl p-4 max-w-xs z-10" style="display: none; min-width: 200px;">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-white font-semibold text-sm">Active Projects</h3>
                    <button id="panel-toggle" class="text-slate-400 hover:text-white transition-colors" title="Minimize">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                </div>
                <div id="project-list" class="space-y-2 overflow-y-auto custom-scrollbar" style="max-height: 180px;">
                    <!-- Project buttons will be inserted here -->
                </div>
            </div>
            
            <!-- Minimized Project Panel -->
            <div id="project-panel-minimized" class="absolute top-4 left-4 bg-slate-800/95 backdrop-blur-sm border-2 border-gray-500 rounded-lg shadow-xl p-3 z-10" style="display: none;">
                <button id="panel-expand" class="text-white hover:text-sky-400 transition-colors flex items-center space-x-2" title="Expand">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                    <span class="text-sm font-medium">Projects</span>
                </button>
            </div>
        </div>

    </div>
</main>
{% endblock content %}

{% block extra_js %}
<script src='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js'></script>
{% endblock extra_js %}

{% block inline_extra_js %}
<script>
    // Get project IDs from the backend context
    const projects = {{ projects|safe }};
    console.log('Projects loaded from backend:', projects);
    const projectIds = projects.map(project => project.id);
    console.log('Project IDs to fetch:', projectIds);
    
    // Global variables for layer management
    let map;
    let projectLayerStates = new Map(); // Track visibility state for each project
    let allProjectLayers = new Map(); // Track all layer IDs for each project
    
    // Get CSRF token from cookie
    function getCSRFToken() {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        return cookieValue || '{{ csrf_token }}';
    }
    
    // Function to toggle layer visibility for a project
    function toggleProjectVisibility(projectId, isVisible) {
        console.log(`Toggling project ${projectId} visibility to: ${isVisible}`);
        
        if (allProjectLayers.has(projectId)) {
            const layerIds = allProjectLayers.get(projectId);
            const visibility = isVisible ? 'visible' : 'none';
            
            layerIds.forEach(layerId => {
                try {
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', visibility);
                        console.log(`Set ${layerId} visibility to ${visibility}`);
                    }
                } catch (error) {
                    console.warn(`Failed to toggle visibility for layer ${layerId}:`, error);
                }
            });
            
            // Update state
            projectLayerStates.set(projectId, isVisible);
        }
    }
    
    // Function to hide loading overlay with smooth transition
    function hideLoadingOverlay() {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.classList.add('hide');
            // Remove from DOM after transition completes
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 500);
        }
    }
    
    // Function to update loading text
    function updateLoadingText(text, subtext = '') {
        const textElement = document.querySelector('.loading-text');
        const subtextElement = document.querySelector('.loading-subtext');
        if (textElement) textElement.textContent = text;
        if (subtextElement) subtextElement.textContent = subtext;
    }

	mapboxgl.accessToken = 'pk.eyJ1IjoiamRla2h0aWFyIiwiYSI6ImNtY2ZyNDBodjBiZ28yb29obnh6YTNrejMifQ.__NkdcDD41lhsuPStJVm4Q';
    
    // Simple function to set map height
    function setMapHeight() {
        const mapElement = document.getElementById('map');
        const rect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const mapTop = rect.top;
        const newHeight = Math.max(viewportHeight - mapTop - 20, 600);
        mapElement.style.height = newHeight + 'px';
    }
    
    if (!mapboxgl.supported()) {
        alert('Your browser does not support Mapbox GL');
    } else {
        // Set initial height
        setMapHeight();
        
        // Show loading overlay
        updateLoadingText('Initializing Map', 'Setting up the survey viewer...');
        
        map = new mapboxgl.Map({
            container: 'map',
            // Satellite imagery with street labels
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            // Start completely zoomed out showing the whole planet
            center: [0, 0],
            zoom: 0
        });
        
        // Add resize listener
        window.addEventListener('resize', () => {
            setMapHeight();
            map.resize();
        });
        
        // Add navigation controls
        map.addControl(new mapboxgl.NavigationControl(), 'top-right');
        
        // Add dynamic scale control with both metric and imperial units
        map.addControl(new mapboxgl.ScaleControl({
            maxWidth: 200,
            unit: 'metric'
        }), 'bottom-right');
        
        // Add a second scale for imperial units
        map.addControl(new mapboxgl.ScaleControl({
            maxWidth: 200,
            unit: 'imperial'
        }), 'bottom-right');

        // Wait for the map to load before adding sources and layers
        map.on('load', function() {
            console.log('Map loaded, fetching GeoJSON data for projects:', projectIds);
            
            // Update loading status
            updateLoadingText('Loading Survey Data', `Downloading GeoJSON for ${projectIds.length} projects...`);
            
            // Hide street-level labels while keeping city/place names
            const labelsToHide = [
                'road-label',  // Street names
                'road-number-shield',  // Road numbers
                'road-exit-shield',  // Highway exit numbers
                'poi-label',  // Points of interest
                'airport-label',  // Airport labels
                'rail-label',  // Rail/transit labels
                'water-point-label',  // Water feature labels
                'natural-point-label',  // Natural feature labels
                'transit-label',  // Transit stop labels
                'road-intersection',  // Intersection labels
                'road-label-simple',  // Simple road labels
                'road-label-large',  // Large road labels
                'road-label-medium',  // Medium road labels
                'road-label-small',  // Small road labels
                'bridge-case-label',  // Bridge labels
                'bridge-label',  // Bridge labels
                'tunnel-label',  // Tunnel labels
                'ferry-label',  // Ferry labels
                'pedestrian-label',  // Pedestrian path labels
                'aerialway-label',  // Aerial way labels
                'building-label',  // Building labels
                'housenum-label'  // House number labels
            ];
            
            // Try to hide each label layer - some may not exist in this style
            labelsToHide.forEach(layerId => {
                try {
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', 'none');
                        console.log(`Hidden label layer: ${layerId}`);
                    }
                } catch (e) {
                    // Layer might not exist in this style, which is fine
                }
            });
            
            // Keep these layers visible (city/place names)
            const labelsToKeep = [
                'place-label',  // General place labels
                'place-city-label',  // City labels
                'place-town-label',  // Town labels
                'place-village-label',  // Village labels
                'place-hamlet-label',  // Hamlet labels
                'place-suburb-label',  // Suburb labels
                'place-neighborhood-label',  // Neighborhood labels
                'country-label',  // Country labels
                'state-label',  // State/province labels
                'settlement-label',  // Settlement labels
                'settlement-major-label',  // Major settlement labels
                'settlement-minor-label'  // Minor settlement labels
            ];
            
            console.log('Street labels hidden, keeping only place/city names');
            
            // More comprehensive approach: inspect all layers and hide based on patterns
            const style = map.getStyle();
            if (style && style.layers) {
                style.layers.forEach(layer => {
                    if (layer.type === 'symbol' && layer.id) {
                        // Hide layers that contain road/street/poi related terms
                        if (layer.id.includes('road') || 
                            layer.id.includes('street') || 
                            layer.id.includes('highway') ||
                            layer.id.includes('motorway') ||
                            layer.id.includes('trunk') ||
                            layer.id.includes('primary') ||
                            layer.id.includes('secondary') ||
                            layer.id.includes('tertiary') ||
                            layer.id.includes('residential') ||
                            layer.id.includes('service') ||
                            layer.id.includes('link') ||
                            layer.id.includes('pedestrian') ||
                            layer.id.includes('poi') ||
                            layer.id.includes('airport') && !layer.id.includes('airport-label-major') ||
                            layer.id.includes('rail') ||
                            layer.id.includes('transit') ||
                            layer.id.includes('bridge') ||
                            layer.id.includes('tunnel') ||
                            layer.id.includes('ferry') ||
                            layer.id.includes('path') ||
                            layer.id.includes('track') ||
                            layer.id.includes('steps') ||
                            layer.id.includes('building') ||
                            layer.id.includes('housenum') ||
                            layer.id.includes('address')) {
                            
                            // Don't hide if it's a place/city/settlement layer
                            if (!layer.id.includes('place') && 
                                !layer.id.includes('city') && 
                                !layer.id.includes('town') &&
                                !layer.id.includes('village') &&
                                !layer.id.includes('settlement') &&
                                !layer.id.includes('country') &&
                                !layer.id.includes('state')) {
                                
                                try {
                                    map.setLayoutProperty(layer.id, 'visibility', 'none');
                                    console.log(`Hidden layer: ${layer.id}`);
                                } catch (e) {
                                    console.warn(`Could not hide layer ${layer.id}:`, e);
                                }
                            }
                        }
                    }
                });
            }
            
            // Maximally distinguishable color palette based on perceptual color theory
            // These 20 colors are optimized for maximum visual distinction
            const colors = [
                '#e41a1c', // Red
                '#377eb8', // Blue  
                '#4daf4a', // Green
                '#984ea3', // Purple
                '#ff7f00', // Orange
                '#ffff33', // Yellow
                '#a65628', // Brown
                '#f781bf', // Pink
                '#999999', // Gray
                '#66c2a5', // Teal
                '#fc8d62', // Salmon
                '#8da0cb', // Lavender
                '#e78ac3', // Rose
                '#a6d854', // Lime
                '#ffd92f', // Gold
                '#e5c494', // Tan
                '#b3b3b3', // Light Gray
                '#1b9e77', // Dark Teal
                '#d95f02', // Dark Orange
                '#7570b3'  // Slate Blue
            ];
            
            console.log(`🎨 Color palette loaded: ${colors.length} maximally distinguishable colors`);
            
            // Create promises to fetch GeoJSON data from API for each project
            const fetchPromises = projectIds.map((projectId, index) => {
                const apiUrl = `/api/v1/projects/${projectId}/geojson/`;

                console.log('Fetching GeoJSON data for project:', projectId);
                
                return fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken(),
                    },
                    credentials: 'same-origin'
                })
                    .then(response => {
                        console.log(`Project ${projectId} GeoJSON API response status:`, response.status);
                        if (!response.ok) {
                            console.error(`HTTP error for project ${projectId}! status: ${response.status}`);
                            throw new Error(`HTTP error for project ${projectId}! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(apiResponse => {
                        console.log(`Project ${projectId} API response:`, apiResponse);
                        
                        // Check if the response is successful and has data
                        if (!apiResponse.success) {
                            console.warn(`Project ${projectId} API response not successful:`, apiResponse);
                            return null;
                        }
                        
                        if (!apiResponse.data) {
                            console.log(`Project ${projectId} has no data field, skipping`);
                            return null;
                        }
                        
                        // Parse the raw JSON string from the API response
                        let geojsonData;
                        try {
                            geojsonData = JSON.parse(apiResponse.data);
                            console.log(`Project ${projectId} parsed GeoJSON:`, geojsonData);
                        } catch (parseError) {
                            console.error(`Failed to parse GeoJSON for project ${projectId}:`, parseError);
                            console.error(`Raw data was:`, apiResponse.data);
                            return null;
                        }
                        
                        // Check if the parsed GeoJSON is empty
                        if (!geojsonData) {
                            console.log(`Project ${projectId} has null GeoJSON, skipping`);
                            return null;
                        }
                        
                        if (!geojsonData.features) {
                            console.log(`Project ${projectId} has no features property, skipping`);
                            return null;
                        }
                        
                        if (geojsonData.features.length === 0) {
                            console.log(`Project ${projectId} has empty features array, skipping`);
                            return null;
                        }
                        
                        console.log(`✅ Project ${projectId} GeoJSON data loaded successfully!`);
                        console.log(`   Features: ${geojsonData.features.length}`);
                        console.log(`   Feature types:`, geojsonData.features.map(f => f.geometry?.type).filter(Boolean));
                        
                        return { 
                            data: geojsonData, 
                            index, 
                            projectId,
                            projectName: projects.find(p => p.id === projectId)?.name || `Project ${projectId}`
                        };
                    })
                    .catch(error => {
                        console.error(`Error fetching GeoJSON for project ${projectId}:`, error);
                        return null; // Return null for failed requests
                    });
            });

            // Wait for all project GeoJSON data to load
            Promise.all(fetchPromises)
                .then(results => {
                    console.log('🔍 Promise.all results:', results);
                    console.log(`📊 Total API calls: ${results.length}`);
                    console.log(`❌ Null results: ${results.filter(r => r === null).length}`);
                    
                    // Filter out null results (projects with no/invalid GeoJSON data)
                    const validResults = results.filter(result => result !== null);
                    console.log(`✅ Valid results: ${validResults.length}`);
                    
                    if (validResults.length === 0) {
                        console.log('❌ No projects have valid GeoJSON data, staying at world view');
                        updateLoadingText('No Survey Data', 'No valid GeoJSON data found in any projects.');
                        setTimeout(() => {
                            hideLoadingOverlay();
                        }, 2000);
                        return;
                    }
                    
                    console.log('📋 Projects to be processed:');
                    validResults.forEach((result, idx) => {
                        console.log(`  ${idx + 1}. ${result.projectName} (${result.projectId}) - ${result.data.features.length} features`);
                    });
                    
                    const firstDatasetBounds = new mapboxgl.LngLatBounds();
                    const projectBoundsMap = new Map(); // Store bounds for each project
                    
                    // Function to extend bounds with coordinates
                    function extendBounds(coords, bounds) {
                        if (typeof coords[0] === 'number') {
                            // This is a [lng, lat] coordinate
                            bounds.extend(coords);
                        } else if (Array.isArray(coords[0])) {
                            // This is an array of coordinates
                            coords.forEach(coord => extendBounds(coord, bounds));
                        }
                    }

                    // Update loading progress
                    updateLoadingText('Processing Survey Data', `Processing ${validResults.length} projects with valid data...`);
                    
                    // Process each project's GeoJSON data
                    validResults.forEach(({ data, index, projectId, projectName }, resultIndex) => {
                        const sourceId = `project-geojson-${projectId}`;
                        const color = colors[resultIndex % colors.length];
                        
                        console.log(`🎨 Processing project ${resultIndex + 1}/${validResults.length}: "${projectName}" (${projectId}) with color ${color}`);
                        
                        // Initialize layer tracking for this project
                        const projectLayers = [];
                        projectLayerStates.set(projectId, true); // Default to visible
                        
                        // Calculate and log bounds for this project
                        const projectBounds = new mapboxgl.LngLatBounds();
                        data.features.forEach(feature => {
                            if (feature.geometry && feature.geometry.coordinates) {
                                extendBounds(feature.geometry.coordinates, projectBounds);
                            }
                        });
                        
                        if (!projectBounds.isEmpty()) {
                            const sw = projectBounds.getSouthWest();
                            const ne = projectBounds.getNorthEast();
                            console.log(`📍 "${projectName}" bounds: SW[${sw.lng.toFixed(6)}, ${sw.lat.toFixed(6)}] to NE[${ne.lng.toFixed(6)}, ${ne.lat.toFixed(6)}]`);
                            
                            // Store bounds for this project
                            projectBoundsMap.set(projectId, {
                                bounds: projectBounds,
                                name: projectName,
                                color: color
                            });
                        }
                        
                        // Add the GeoJSON source
                        map.addSource(sourceId, {
                            type: 'geojson',
                            data: data
                        });
                        
                        console.log(`✅ Added source: ${sourceId}`);

                        // Determine geometry types for this project
                        const geometryTypes = new Set();
                        if (data.features) {
                            data.features.forEach(feature => {
                                if (feature.geometry) {
                                    geometryTypes.add(feature.geometry.type);
                                    // Only extend bounds for the FIRST valid project (resultIndex 0)
                                    if (resultIndex === 0 && feature.geometry.coordinates) {
                                        extendBounds(feature.geometry.coordinates, firstDatasetBounds);
                                    }
                                }
                            });
                        }
                        
                        console.log(`Project "${projectName}" geometry types:`, Array.from(geometryTypes));

                        let layersAdded = 0;
                        
                        // Add layers based on geometry types
                        if (geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                            const fillLayerId = `project-fill-${projectId}`;
                            const strokeLayerId = `project-stroke-${projectId}`;
                            
                            // Add fill layer for polygons
                            map.addLayer({
                                id: fillLayerId,
                                type: 'fill',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'fill-color': color,
                                    'fill-opacity': 0.6
                                }
                            });
                            console.log(`Added fill layer: ${fillLayerId} for project "${projectName}" with color ${color}`);
                            projectLayers.push(fillLayerId);
                            layersAdded++;

                            // Add stroke for polygons
                            map.addLayer({
                                id: strokeLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'line-color': '#000',
                                    'line-width': 2
                                }
                            });
                            console.log(`Added stroke layer: ${strokeLayerId} for project "${projectName}"`);
                            projectLayers.push(strokeLayerId);
                            layersAdded++;
                        }

                        if (geometryTypes.has('LineString') || geometryTypes.has('MultiLineString')) {
                            const lineLayerId = `project-line-${projectId}`;
                            const lineLabelLayerId = `project-line-labels-${projectId}`;
                            
                            // Use consistent small line width for all projects
                            const lineWidth = 2; // Fixed small width for all lines
                            
                            map.addLayer({
                                id: lineLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'LineString'],
                                layout: {},
                                paint: {
                                    'line-color': color,
                                    'line-width': lineWidth,
                                    'line-opacity': 0.8
                                }
                            });
                            console.log(`Added line layer: ${lineLayerId} for project "${projectName}" with color ${color} and width ${lineWidth}px`);
                            projectLayers.push(lineLayerId);
                            layersAdded++;
                            
                            // Add labels for lines (only visible when zoomed in)
                            map.addLayer({
                                id: lineLabelLayerId,
                                type: 'symbol',
                                source: sourceId,
                                filter: ['all', 
                                    ['in', '$type', 'LineString'],
                                    ['has', 'Name']  // Only show labels for features with a Name property
                                ],
                                minzoom: 13,  // Only show labels when zoomed in to level 13 or higher
                                layout: {
                                    'text-field': ['get', 'Name'],
                                    'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'],
                                    'text-size': 12,
                                    'symbol-placement': 'line',  // Place text along the line
                                    'text-rotation-alignment': 'map',  // Rotate text with the map
                                    'text-pitch-alignment': 'viewport'  // Keep text upright
                                },
                                paint: {
                                    'text-color': '#ffffff',
                                    'text-halo-color': '#000000',
                                    'text-halo-width': 2,
                                    'text-halo-blur': 1
                                }
                            });
                            console.log(`Added line label layer: ${lineLabelLayerId} for project "${projectName}" (visible at zoom 13+)`);
                            projectLayers.push(lineLabelLayerId);
                            layersAdded++;
                        }

                        if (geometryTypes.has('Point') || geometryTypes.has('MultiPoint')) {
                            const pointLayerId = `project-points-${projectId}`;
                            
                            // Add circle layer for points
                            map.addLayer({
                                id: pointLayerId,
                                type: 'circle',
                                source: sourceId,
                                filter: ['in', '$type', 'Point'],
                                layout: {},
                                paint: {
                                    'circle-color': color,
                                    'circle-radius': 6,
                                    'circle-stroke-color': '#ffffff',
                                    'circle-stroke-width': 2
                                }
                            });
                            console.log(`Added points layer: ${pointLayerId} for project "${projectName}" with color ${color}`);
                            projectLayers.push(pointLayerId);
                            layersAdded++;
                        }
                        
                        // Store layer IDs for this project
                        allProjectLayers.set(projectId, projectLayers);
                        console.log(`🎯 Total layers added for "${projectName}": ${layersAdded}`);
                    });

                    // Summary of what was loaded
                    console.log(`SUMMARY: Successfully loaded GeoJSON data for ${validResults.length} out of ${projectIds.length} projects:`);
                    validResults.forEach(({ data, projectId, projectName }) => {
                        const featureCount = data.features ? data.features.length : 0;
                        console.log(`  Project "${projectName}" (${projectId}): ${featureCount} features`);
                    });
                    
                    // Populate the project panel
                    const projectListDiv = document.getElementById('project-list');
                    const projectPanel = document.getElementById('project-panel');
                    
                    if (projectBoundsMap.size > 0) {
                        projectListDiv.innerHTML = ''; // Clear existing content
                        
                        // Convert Map to array and sort by project name (case-insensitive)
                        const sortedProjects = Array.from(projectBoundsMap.entries())
                            .sort((a, b) => {
                                const nameA = a[1].name.toLowerCase();
                                const nameB = b[1].name.toLowerCase();
                                return nameA.localeCompare(nameB);
                            });
                        
                        // Create buttons for sorted projects
                        sortedProjects.forEach(([projectId, projectData]) => {
                            const buttonContainer = document.createElement('div');
                            buttonContainer.className = 'project-button';
                            
                            // Create clickable content area
                            const buttonContent = document.createElement('div');
                            buttonContent.className = 'project-button-content';
                            
                            // Create color indicator
                            const colorDot = document.createElement('span');
                            colorDot.className = 'project-color-dot';
                            colorDot.style.backgroundColor = projectData.color;
                            
                            // Create text span
                            const textSpan = document.createElement('span');
                            textSpan.className = 'project-name';
                            textSpan.textContent = projectData.name;
                            
                            buttonContent.appendChild(colorDot);
                            buttonContent.appendChild(textSpan);
                            
                            // Add click handler to the entire card to center on project
                            buttonContainer.addEventListener('click', () => {
                                map.fitBounds(projectData.bounds, {
                                    padding: 100,
                                    maxZoom: 15,
                                    duration: 1500
                                });
                            });
                            
                            // Create toggle switch
                            const toggleContainer = document.createElement('label');
                            toggleContainer.className = 'toggle-switch';
                            
                            const toggleInput = document.createElement('input');
                            toggleInput.type = 'checkbox';
                            toggleInput.checked = true; // Default to visible
                            
                            const toggleSlider = document.createElement('span');
                            toggleSlider.className = 'toggle-slider';
                            
                            // Add toggle event handler with event stopping
                            toggleContainer.addEventListener('click', (e) => {
                                e.stopPropagation(); // Prevent triggering the map center action
                            });
                            
                            toggleInput.addEventListener('change', (e) => {
                                const isVisible = e.target.checked;
                                toggleProjectVisibility(projectId, isVisible);
                            });
                            
                            toggleContainer.appendChild(toggleInput);
                            toggleContainer.appendChild(toggleSlider);
                            
                            // Assemble the button
                            buttonContainer.appendChild(buttonContent);
                            buttonContainer.appendChild(toggleContainer);
                            
                            projectListDiv.appendChild(buttonContainer);
                        });
                        
                        // Show the panel
                        projectPanel.style.display = 'block';
                        
                        // Add minimize/expand functionality
                        const minimizedPanel = document.getElementById('project-panel-minimized');
                        const toggleBtn = document.getElementById('panel-toggle');
                        const expandBtn = document.getElementById('panel-expand');
                        
                        toggleBtn.addEventListener('click', () => {
                            projectPanel.style.display = 'none';
                            minimizedPanel.style.display = 'block';
                        });
                        
                        expandBtn.addEventListener('click', () => {
                            minimizedPanel.style.display = 'none';
                            projectPanel.style.display = 'block';
                        });
                    }

                    // Hide loading overlay now that everything is ready
                    setTimeout(() => {
                        hideLoadingOverlay();
                    }, 300); // Small delay to ensure UI is fully rendered
                    
                    // Fit the map to the FIRST project bounds only with smooth animation
                    if (!firstDatasetBounds.isEmpty()) {
                        console.log('Fitting map to first project bounds:', firstDatasetBounds);
                        console.log(`Zooming to: ${validResults[0].projectName} (${validResults[0].projectId})`);
                        
                        // Wait for loading overlay to start hiding before starting zoom
                        setTimeout(() => {
                            map.fitBounds(firstDatasetBounds, {
                                padding: 200, // Increased padding for wider view
                                maxZoom: 11,  // Limit zoom to show ~100km² area (zoom 11 ≈ 10km x 10km area)
                                duration: 6000, // 6 second smooth animation (very cinematic)
                                essential: true // Animation will complete even if user interacts
                            });
                        }, 800); // Start zoom after loading overlay transition
                    } else {
                        console.log('No valid bounds found in first project, staying at world view');
                        // Keep the world view if no valid data
                    }
                })
                .catch(error => {
                    console.error('Error loading project GeoJSON data:', error);
                    updateLoadingText('Error Loading Data', 'Failed to load survey data. Check console for details.');
                    setTimeout(() => {
                        hideLoadingOverlay();
                        alert('Error loading project GeoJSON data. Check the console for details.');
                    }, 2000);
                    // Fallback to a default view if GeoJSON fails to load
                    map.setCenter([0, 0]);
                    map.setZoom(2);
                });
        });
    }
</script>
{% endblock inline_extra_js %}
