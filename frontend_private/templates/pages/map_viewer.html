{% extends "base_private.html" %}
{% load static i18n compress%}

{% block extra_css %}
<link href='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css' rel='stylesheet' />
<style>
    /* Custom scrollbar for project list */
    .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(51, 65, 85, 0.5); /* slate-700 with opacity */
        border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgba(148, 163, 184, 0.8); /* slate-400 with opacity */
        border-radius: 3px;
    }
    
    .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgba(203, 213, 225, 0.9); /* slate-300 with opacity */
    }
</style>
{% endblock extra_css %}

{% block content %}
<main class="grow">
    <div class="px-4 sm:px-6 lg:px-8 py-8 w-full max-w-9xl mx-auto">

        <!-- Page header -->
        <div class="sm:flex sm:justify-between sm:items-center mb-8">

            <!-- Left: Title -->
            <div class="mb-4 sm:mb-0">
                <h1 class="text-2xl md:text-3xl text-slate-100 font-bold">
                    Survey Viewer
                </h1>
            </div>

            <!-- Right: Actions -->
            <div class="grid grid-flow-col sm:auto-cols-max justify-start sm:justify-end gap-2">

                <!-- New button -->
                <button class="btn bg-sky-500 hover:bg-sky-600 text-white">
                    <svg class="w-4 h-4 stroke-current fill-none shrink-0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="3.5 3.51 17 16.97">
                        <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                    <a id="btn_release_all_locks" class="hidden xs:block ml-2">Refresh all my Projects</a>
                </button>

            </div>

        </div>

        <!-- Table -->
        <div class="bg-slate-800 shadow-lg rounded-sm border border-slate-200 border-slate-700 relative">
            <div id='map' style='width: 100%; min-height: 600px; display: block;'></div>
            
            <!-- Floating Project List Panel -->
            <div id="project-panel" class="absolute top-4 left-4 bg-slate-800/95 backdrop-blur-sm border-2 border-gray-500 rounded-lg shadow-xl p-4 max-w-xs z-10" style="display: none; min-width: 200px;">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-white font-semibold text-sm">Active Projects</h3>
                    <button id="panel-toggle" class="text-slate-400 hover:text-white transition-colors" title="Minimize">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                        </svg>
                    </button>
                </div>
                <div id="project-list" class="space-y-2 overflow-y-auto custom-scrollbar" style="max-height: 180px;">
                    <!-- Project buttons will be inserted here -->
                </div>
            </div>
            
            <!-- Minimized Project Panel -->
            <div id="project-panel-minimized" class="absolute top-4 left-4 bg-slate-800/95 backdrop-blur-sm border-2 border-gray-500 rounded-lg shadow-xl p-3 z-10" style="display: none;">
                <button id="panel-expand" class="text-white hover:text-sky-400 transition-colors flex items-center space-x-2" title="Expand">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                    </svg>
                    <span class="text-sm font-medium">Projects</span>
                </button>
            </div>
        </div>

    </div>
</main>
{% endblock content %}

{% block extra_js %}
<script src='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js'></script>
{% endblock extra_js %}

{% block inline_extra_js %}
<script>
    // Get project IDs from the backend context
    const projects = {{ projects|safe }};
    console.log('Projects loaded from backend:', projects);
    const projectIds = projects.map(project => project.id);
    console.log('Project IDs to fetch:', projectIds);
    
    // Get CSRF token from cookie
    function getCSRFToken() {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        return cookieValue || '{{ csrf_token }}';
    }

	mapboxgl.accessToken = 'pk.eyJ1IjoiamRla2h0aWFyIiwiYSI6ImNtY2ZyNDBodjBiZ28yb29obnh6YTNrejMifQ.__NkdcDD41lhsuPStJVm4Q';
    
    // Simple function to set map height
    function setMapHeight() {
        const mapElement = document.getElementById('map');
        const rect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const mapTop = rect.top;
        const newHeight = Math.max(viewportHeight - mapTop - 20, 600);
        mapElement.style.height = newHeight + 'px';
    }
    
    if (!mapboxgl.supported()) {
        alert('Your browser does not support Mapbox GL');
    } else {
        // Set initial height
        setMapHeight();
        
        const map = new mapboxgl.Map({
            container: 'map',
            // Satellite imagery with street labels
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            // Start completely zoomed out showing the whole planet
            center: [0, 0],
            zoom: 0
        });
        
        // Add resize listener
        window.addEventListener('resize', () => {
            setMapHeight();
            map.resize();
        });
        
        // Add navigation controls
        map.addControl(new mapboxgl.NavigationControl(), 'top-right');
        
        // Add dynamic scale control with both metric and imperial units
        map.addControl(new mapboxgl.ScaleControl({
            maxWidth: 200,
            unit: 'metric'
        }), 'bottom-right');
        
        // Add a second scale for imperial units
        map.addControl(new mapboxgl.ScaleControl({
            maxWidth: 200,
            unit: 'imperial'
        }), 'bottom-right');

        // Wait for the map to load before adding sources and layers
        map.on('load', function() {
            console.log('Map loaded, fetching GeoJSON data for projects:', projectIds);
            
            // Hide street-level labels while keeping city/place names
            const labelsToHide = [
                'road-label',  // Street names
                'road-number-shield',  // Road numbers
                'road-exit-shield',  // Highway exit numbers
                'poi-label',  // Points of interest
                'airport-label',  // Airport labels
                'rail-label',  // Rail/transit labels
                'water-point-label',  // Water feature labels
                'natural-point-label',  // Natural feature labels
                'transit-label',  // Transit stop labels
                'road-intersection',  // Intersection labels
                'road-label-simple',  // Simple road labels
                'road-label-large',  // Large road labels
                'road-label-medium',  // Medium road labels
                'road-label-small',  // Small road labels
                'bridge-case-label',  // Bridge labels
                'bridge-label',  // Bridge labels
                'tunnel-label',  // Tunnel labels
                'ferry-label',  // Ferry labels
                'pedestrian-label',  // Pedestrian path labels
                'aerialway-label',  // Aerial way labels
                'building-label',  // Building labels
                'housenum-label'  // House number labels
            ];
            
            // Try to hide each label layer - some may not exist in this style
            labelsToHide.forEach(layerId => {
                try {
                    if (map.getLayer(layerId)) {
                        map.setLayoutProperty(layerId, 'visibility', 'none');
                        console.log(`Hidden label layer: ${layerId}`);
                    }
                } catch (e) {
                    // Layer might not exist in this style, which is fine
                }
            });
            
            // Keep these layers visible (city/place names)
            const labelsToKeep = [
                'place-label',  // General place labels
                'place-city-label',  // City labels
                'place-town-label',  // Town labels
                'place-village-label',  // Village labels
                'place-hamlet-label',  // Hamlet labels
                'place-suburb-label',  // Suburb labels
                'place-neighborhood-label',  // Neighborhood labels
                'country-label',  // Country labels
                'state-label',  // State/province labels
                'settlement-label',  // Settlement labels
                'settlement-major-label',  // Major settlement labels
                'settlement-minor-label'  // Minor settlement labels
            ];
            
            console.log('Street labels hidden, keeping only place/city names');
            
            // More comprehensive approach: inspect all layers and hide based on patterns
            const style = map.getStyle();
            if (style && style.layers) {
                style.layers.forEach(layer => {
                    if (layer.type === 'symbol' && layer.id) {
                        // Hide layers that contain road/street/poi related terms
                        if (layer.id.includes('road') || 
                            layer.id.includes('street') || 
                            layer.id.includes('highway') ||
                            layer.id.includes('motorway') ||
                            layer.id.includes('trunk') ||
                            layer.id.includes('primary') ||
                            layer.id.includes('secondary') ||
                            layer.id.includes('tertiary') ||
                            layer.id.includes('residential') ||
                            layer.id.includes('service') ||
                            layer.id.includes('link') ||
                            layer.id.includes('pedestrian') ||
                            layer.id.includes('poi') ||
                            layer.id.includes('airport') && !layer.id.includes('airport-label-major') ||
                            layer.id.includes('rail') ||
                            layer.id.includes('transit') ||
                            layer.id.includes('bridge') ||
                            layer.id.includes('tunnel') ||
                            layer.id.includes('ferry') ||
                            layer.id.includes('path') ||
                            layer.id.includes('track') ||
                            layer.id.includes('steps') ||
                            layer.id.includes('building') ||
                            layer.id.includes('housenum') ||
                            layer.id.includes('address')) {
                            
                            // Don't hide if it's a place/city/settlement layer
                            if (!layer.id.includes('place') && 
                                !layer.id.includes('city') && 
                                !layer.id.includes('town') &&
                                !layer.id.includes('village') &&
                                !layer.id.includes('settlement') &&
                                !layer.id.includes('country') &&
                                !layer.id.includes('state')) {
                                
                                try {
                                    map.setLayoutProperty(layer.id, 'visibility', 'none');
                                    console.log(`Hidden layer: ${layer.id}`);
                                } catch (e) {
                                    console.warn(`Could not hide layer ${layer.id}:`, e);
                                }
                            }
                        }
                    }
                });
            }
            
            // Maximally distinguishable color palette based on perceptual color theory
            // These 20 colors are optimized for maximum visual distinction
            const colors = [
                '#e41a1c', // Red
                '#377eb8', // Blue  
                '#4daf4a', // Green
                '#984ea3', // Purple
                '#ff7f00', // Orange
                '#ffff33', // Yellow
                '#a65628', // Brown
                '#f781bf', // Pink
                '#999999', // Gray
                '#66c2a5', // Teal
                '#fc8d62', // Salmon
                '#8da0cb', // Lavender
                '#e78ac3', // Rose
                '#a6d854', // Lime
                '#ffd92f', // Gold
                '#e5c494', // Tan
                '#b3b3b3', // Light Gray
                '#1b9e77', // Dark Teal
                '#d95f02', // Dark Orange
                '#7570b3'  // Slate Blue
            ];
            
            console.log(`ðŸŽ¨ Color palette loaded: ${colors.length} maximally distinguishable colors`);
            
            // Create promises to fetch GeoJSON data from API for each project
            const fetchPromises = projectIds.map((projectId, index) => {
                const apiUrl = `/api/v1/projects/${projectId}/geojson/`;

                console.log('Fetching GeoJSON data for project:', projectId);
                
                return fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken(),
                    },
                    credentials: 'same-origin'
                })
                    .then(response => {
                        console.log(`Project ${projectId} GeoJSON API response status:`, response.status);
                        if (!response.ok) {
                            console.error(`HTTP error for project ${projectId}! status: ${response.status}`);
                            throw new Error(`HTTP error for project ${projectId}! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(apiResponse => {
                        console.log(`Project ${projectId} API response:`, apiResponse);
                        
                        // Check if the response is successful and has data
                        if (!apiResponse.success) {
                            console.warn(`Project ${projectId} API response not successful:`, apiResponse);
                            return null;
                        }
                        
                        if (!apiResponse.data) {
                            console.log(`Project ${projectId} has no data field, skipping`);
                            return null;
                        }
                        
                        // Parse the raw JSON string from the API response
                        let geojsonData;
                        try {
                            geojsonData = JSON.parse(apiResponse.data);
                            console.log(`Project ${projectId} parsed GeoJSON:`, geojsonData);
                        } catch (parseError) {
                            console.error(`Failed to parse GeoJSON for project ${projectId}:`, parseError);
                            console.error(`Raw data was:`, apiResponse.data);
                            return null;
                        }
                        
                        // Check if the parsed GeoJSON is empty
                        if (!geojsonData) {
                            console.log(`Project ${projectId} has null GeoJSON, skipping`);
                            return null;
                        }
                        
                        if (!geojsonData.features) {
                            console.log(`Project ${projectId} has no features property, skipping`);
                            return null;
                        }
                        
                        if (geojsonData.features.length === 0) {
                            console.log(`Project ${projectId} has empty features array, skipping`);
                            return null;
                        }
                        
                        console.log(`âœ… Project ${projectId} GeoJSON data loaded successfully!`);
                        console.log(`   Features: ${geojsonData.features.length}`);
                        console.log(`   Feature types:`, geojsonData.features.map(f => f.geometry?.type).filter(Boolean));
                        
                        return { 
                            data: geojsonData, 
                            index, 
                            projectId,
                            projectName: projects.find(p => p.id === projectId)?.name || `Project ${projectId}`
                        };
                    })
                    .catch(error => {
                        console.error(`Error fetching GeoJSON for project ${projectId}:`, error);
                        return null; // Return null for failed requests
                    });
            });

            // Wait for all project GeoJSON data to load
            Promise.all(fetchPromises)
                .then(results => {
                    console.log('ðŸ” Promise.all results:', results);
                    console.log(`ðŸ“Š Total API calls: ${results.length}`);
                    console.log(`âŒ Null results: ${results.filter(r => r === null).length}`);
                    
                    // Filter out null results (projects with no/invalid GeoJSON data)
                    const validResults = results.filter(result => result !== null);
                    console.log(`âœ… Valid results: ${validResults.length}`);
                    
                    if (validResults.length === 0) {
                        console.log('âŒ No projects have valid GeoJSON data, staying at world view');
                        return;
                    }
                    
                    console.log('ðŸ“‹ Projects to be processed:');
                    validResults.forEach((result, idx) => {
                        console.log(`  ${idx + 1}. ${result.projectName} (${result.projectId}) - ${result.data.features.length} features`);
                    });
                    
                    const firstDatasetBounds = new mapboxgl.LngLatBounds();
                    const projectBoundsMap = new Map(); // Store bounds for each project
                    
                    // Function to extend bounds with coordinates
                    function extendBounds(coords, bounds) {
                        if (typeof coords[0] === 'number') {
                            // This is a [lng, lat] coordinate
                            bounds.extend(coords);
                        } else if (Array.isArray(coords[0])) {
                            // This is an array of coordinates
                            coords.forEach(coord => extendBounds(coord, bounds));
                        }
                    }

                    // Process each project's GeoJSON data
                    validResults.forEach(({ data, index, projectId, projectName }, resultIndex) => {
                        const sourceId = `project-geojson-${projectId}`;
                        const color = colors[resultIndex % colors.length];
                        
                        console.log(`ðŸŽ¨ Processing project ${resultIndex + 1}/${validResults.length}: "${projectName}" (${projectId}) with color ${color}`);
                        
                        // Calculate and log bounds for this project
                        const projectBounds = new mapboxgl.LngLatBounds();
                        data.features.forEach(feature => {
                            if (feature.geometry && feature.geometry.coordinates) {
                                extendBounds(feature.geometry.coordinates, projectBounds);
                            }
                        });
                        
                        if (!projectBounds.isEmpty()) {
                            const sw = projectBounds.getSouthWest();
                            const ne = projectBounds.getNorthEast();
                            console.log(`ðŸ“ "${projectName}" bounds: SW[${sw.lng.toFixed(6)}, ${sw.lat.toFixed(6)}] to NE[${ne.lng.toFixed(6)}, ${ne.lat.toFixed(6)}]`);
                            
                            // Store bounds for this project
                            projectBoundsMap.set(projectId, {
                                bounds: projectBounds,
                                name: projectName,
                                color: color
                            });
                        }
                        
                        // Add the GeoJSON source
                        map.addSource(sourceId, {
                            type: 'geojson',
                            data: data
                        });
                        
                        console.log(`âœ… Added source: ${sourceId}`);

                        // Determine geometry types for this project
                        const geometryTypes = new Set();
                        if (data.features) {
                            data.features.forEach(feature => {
                                if (feature.geometry) {
                                    geometryTypes.add(feature.geometry.type);
                                    // Only extend bounds for the FIRST valid project (resultIndex 0)
                                    if (resultIndex === 0 && feature.geometry.coordinates) {
                                        extendBounds(feature.geometry.coordinates, firstDatasetBounds);
                                    }
                                }
                            });
                        }
                        
                        console.log(`Project "${projectName}" geometry types:`, Array.from(geometryTypes));

                        let layersAdded = 0;
                        
                        // Add layers based on geometry types
                        if (geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                            const fillLayerId = `project-fill-${projectId}`;
                            const strokeLayerId = `project-stroke-${projectId}`;
                            
                            // Add fill layer for polygons
                            map.addLayer({
                                id: fillLayerId,
                                type: 'fill',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'fill-color': color,
                                    'fill-opacity': 0.6
                                }
                            });
                            console.log(`Added fill layer: ${fillLayerId} for project "${projectName}" with color ${color}`);
                            layersAdded++;

                            // Add stroke for polygons
                            map.addLayer({
                                id: strokeLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'line-color': '#000',
                                    'line-width': 2
                                }
                            });
                            console.log(`Added stroke layer: ${strokeLayerId} for project "${projectName}"`);
                            layersAdded++;
                        }

                        if (geometryTypes.has('LineString') || geometryTypes.has('MultiLineString')) {
                            const lineLayerId = `project-line-${projectId}`;
                            const lineLabelLayerId = `project-line-labels-${projectId}`;
                            
                            // Use consistent small line width for all projects
                            const lineWidth = 2; // Fixed small width for all lines
                            
                            map.addLayer({
                                id: lineLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'LineString'],
                                layout: {},
                                paint: {
                                    'line-color': color,
                                    'line-width': lineWidth,
                                    'line-opacity': 0.8
                                }
                            });
                            console.log(`Added line layer: ${lineLayerId} for project "${projectName}" with color ${color} and width ${lineWidth}px`);
                            layersAdded++;
                            
                            // Add labels for lines (only visible when zoomed in)
                            map.addLayer({
                                id: lineLabelLayerId,
                                type: 'symbol',
                                source: sourceId,
                                filter: ['all', 
                                    ['in', '$type', 'LineString'],
                                    ['has', 'Name']  // Only show labels for features with a Name property
                                ],
                                minzoom: 13,  // Only show labels when zoomed in to level 13 or higher
                                layout: {
                                    'text-field': ['get', 'Name'],
                                    'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'],
                                    'text-size': 12,
                                    'symbol-placement': 'line',  // Place text along the line
                                    'text-rotation-alignment': 'map',  // Rotate text with the map
                                    'text-pitch-alignment': 'viewport'  // Keep text upright
                                },
                                paint: {
                                    'text-color': '#ffffff',
                                    'text-halo-color': '#000000',
                                    'text-halo-width': 2,
                                    'text-halo-blur': 1
                                }
                            });
                            console.log(`Added line label layer: ${lineLabelLayerId} for project "${projectName}" (visible at zoom 13+)`);
                            layersAdded++;
                        }

                        if (geometryTypes.has('Point') || geometryTypes.has('MultiPoint')) {
                            const pointLayerId = `project-points-${projectId}`;
                            
                            // Add circle layer for points
                            map.addLayer({
                                id: pointLayerId,
                                type: 'circle',
                                source: sourceId,
                                filter: ['in', '$type', 'Point'],
                                layout: {},
                                paint: {
                                    'circle-color': color,
                                    'circle-radius': 6,
                                    'circle-stroke-color': '#ffffff',
                                    'circle-stroke-width': 2
                                }
                            });
                            console.log(`Added points layer: ${pointLayerId} for project "${projectName}" with color ${color}`);
                            layersAdded++;
                        }
                        
                        console.log(`ðŸŽ¯ Total layers added for "${projectName}": ${layersAdded}`);
                    });

                    // Summary of what was loaded
                    console.log(`SUMMARY: Successfully loaded GeoJSON data for ${validResults.length} out of ${projectIds.length} projects:`);
                    validResults.forEach(({ data, projectId, projectName }) => {
                        const featureCount = data.features ? data.features.length : 0;
                        console.log(`  Project "${projectName}" (${projectId}): ${featureCount} features`);
                    });
                    
                    // Populate the project panel
                    const projectListDiv = document.getElementById('project-list');
                    const projectPanel = document.getElementById('project-panel');
                    
                    if (projectBoundsMap.size > 0) {
                        projectListDiv.innerHTML = ''; // Clear existing content
                        
                        // Convert Map to array and sort by project name (case-insensitive)
                        const sortedProjects = Array.from(projectBoundsMap.entries())
                            .sort((a, b) => {
                                const nameA = a[1].name.toLowerCase();
                                const nameB = b[1].name.toLowerCase();
                                return nameA.localeCompare(nameB);
                            });
                        
                        // Create buttons for sorted projects
                        sortedProjects.forEach(([projectId, projectData]) => {
                            const button = document.createElement('button');
                            button.className = 'w-full text-left px-3 py-1.5 rounded-md bg-slate-700 hover:bg-slate-600 text-white text-sm transition-colors duration-200 flex items-center space-x-2';
                            
                            // Create color indicator
                            const colorDot = document.createElement('span');
                            colorDot.className = 'w-3 h-3 rounded-full flex-shrink-0';
                            colorDot.style.backgroundColor = projectData.color;
                            
                            // Create text span
                            const textSpan = document.createElement('span');
                            textSpan.className = 'truncate';
                            textSpan.textContent = projectData.name;
                            
                            button.appendChild(colorDot);
                            button.appendChild(textSpan);
                            
                            // Add click handler to center on project
                            button.addEventListener('click', () => {
                                map.fitBounds(projectData.bounds, {
                                    padding: 100,
                                    maxZoom: 15,
                                    duration: 1500
                                });
                            });
                            
                            projectListDiv.appendChild(button);
                        });
                        
                        // Show the panel
                        projectPanel.style.display = 'block';
                        
                        // Add minimize/expand functionality
                        const minimizedPanel = document.getElementById('project-panel-minimized');
                        const toggleBtn = document.getElementById('panel-toggle');
                        const expandBtn = document.getElementById('panel-expand');
                        
                        toggleBtn.addEventListener('click', () => {
                            projectPanel.style.display = 'none';
                            minimizedPanel.style.display = 'block';
                        });
                        
                        expandBtn.addEventListener('click', () => {
                            minimizedPanel.style.display = 'none';
                            projectPanel.style.display = 'block';
                        });
                    }

                    // Fit the map to the FIRST project bounds only with smooth animation
                    if (!firstDatasetBounds.isEmpty()) {
                        console.log('Fitting map to first project bounds:', firstDatasetBounds);
                        console.log(`Zooming to: ${validResults[0].projectName} (${validResults[0].projectId})`);
                        map.fitBounds(firstDatasetBounds, {
                            padding: 200, // Increased padding for wider view
                            maxZoom: 11,  // Limit zoom to show ~100kmÂ² area (zoom 11 â‰ˆ 10km x 10km area)
                            duration: 6000, // 6 second smooth animation (very cinematic)
                            essential: true // Animation will complete even if user interacts
                        });
                    } else {
                        console.log('No valid bounds found in first project, staying at world view');
                        // Keep the world view if no valid data
                    }
                })
                .catch(error => {
                    console.error('Error loading project GeoJSON data:', error);
                    alert('Error loading project GeoJSON data. Check the console for details.');
                    // Fallback to a default view if GeoJSON fails to load
                    map.setCenter([0, 0]);
                    map.setZoom(2);
                });
        });
    }
</script>
{% endblock inline_extra_js %}
