{% extends "base_private.html" %}
{% load static i18n compress%}

{% block extra_css %}
<link href='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css' rel='stylesheet' />
{% endblock extra_css %}

{% block content %}
<main class="grow">
    <div class="px-4 sm:px-6 lg:px-8 py-8 w-full max-w-9xl mx-auto">

        <!-- Page header -->
        <div class="sm:flex sm:justify-between sm:items-center mb-8">

            <!-- Left: Title -->
            <div class="mb-4 sm:mb-0">
                <h1 class="text-2xl md:text-3xl text-slate-100 font-bold">
                    Survey Viewer
                </h1>
            </div>

            <!-- Right: Actions -->
            <div class="grid grid-flow-col sm:auto-cols-max justify-start sm:justify-end gap-2">

                <!-- New button -->
                <button class="btn bg-sky-500 hover:bg-sky-600 text-white">
                    <svg class="w-4 h-4 stroke-current fill-none shrink-0" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" viewBox="3.5 3.51 17 16.97">
                        <path d="M20 11a8.1 8.1 0 0 0 -15.5 -2m-.5 -4v4h4"></path>
                        <path d="M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"></path>
                    </svg>
                    <a id="btn_release_all_locks" class="hidden xs:block ml-2">Refresh all my Projects</a>
                </button>

            </div>

        </div>

        <!-- Table -->
        <div class="bg-slate-800 shadow-lg rounded-sm border border-slate-200 border-slate-700">
            <div id='map' style='width: 100%; min-height: 600px; display: block;'></div>
        </div>

    </div>
</main>
{% endblock content %}

{% block extra_js %}
<script src='https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js'></script>
{% endblock extra_js %}

{% block inline_extra_js %}
<script>
    // Get project IDs from the backend context
    const projects = {{ projects|safe }};
    console.log('Projects loaded from backend:', projects);
    const projectIds = projects.map(project => project.id);
    console.log('Project IDs to fetch:', projectIds);
    
    // Get CSRF token from cookie
    function getCSRFToken() {
        const cookieValue = document.cookie
            .split('; ')
            .find(row => row.startsWith('csrftoken='))
            ?.split('=')[1];
        return cookieValue || '{{ csrf_token }}';
    }

	mapboxgl.accessToken = 'pk.eyJ1IjoiamRla2h0aWFyIiwiYSI6ImNtY2ZyNDBodjBiZ28yb29obnh6YTNrejMifQ.__NkdcDD41lhsuPStJVm4Q';
    
    // Simple function to set map height
    function setMapHeight() {
        const mapElement = document.getElementById('map');
        const rect = mapElement.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        const mapTop = rect.top;
        const newHeight = Math.max(viewportHeight - mapTop - 20, 600);
        mapElement.style.height = newHeight + 'px';
    }
    
    if (!mapboxgl.supported()) {
        alert('Your browser does not support Mapbox GL');
    } else {
        // Set initial height
        setMapHeight();
        
        const map = new mapboxgl.Map({
            container: 'map',
            // Satellite imagery with street labels
            style: 'mapbox://styles/mapbox/satellite-streets-v12',
            // Start completely zoomed out showing the whole planet
            center: [0, 0],
            zoom: 0
        });
        
        // Add resize listener
        window.addEventListener('resize', () => {
            setMapHeight();
            map.resize();
        });

        // Wait for the map to load before adding sources and layers
        map.on('load', function() {
            console.log('Map loaded, fetching GeoJSON data for projects:', projectIds);
            
            // Maximally distinguishable color palette based on perceptual color theory
            // These 20 colors are optimized for maximum visual distinction
            const colors = [
                '#e41a1c', // Red
                '#377eb8', // Blue  
                '#4daf4a', // Green
                '#984ea3', // Purple
                '#ff7f00', // Orange
                '#ffff33', // Yellow
                '#a65628', // Brown
                '#f781bf', // Pink
                '#999999', // Gray
                '#66c2a5', // Teal
                '#fc8d62', // Salmon
                '#8da0cb', // Lavender
                '#e78ac3', // Rose
                '#a6d854', // Lime
                '#ffd92f', // Gold
                '#e5c494', // Tan
                '#b3b3b3', // Light Gray
                '#1b9e77', // Dark Teal
                '#d95f02', // Dark Orange
                '#7570b3'  // Slate Blue
            ];
            
            console.log(`ðŸŽ¨ Color palette loaded: ${colors.length} maximally distinguishable colors`);
            
            // Create promises to fetch GeoJSON data from API for each project
            const fetchPromises = projectIds.map((projectId, index) => {
                const apiUrl = `/api/v1/projects/${projectId}/geojson/`;

                console.log('Fetching GeoJSON data for project:', projectId);
                
                return fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCSRFToken(),
                    },
                    credentials: 'same-origin'
                })
                    .then(response => {
                        console.log(`Project ${projectId} GeoJSON API response status:`, response.status);
                        if (!response.ok) {
                            console.error(`HTTP error for project ${projectId}! status: ${response.status}`);
                            throw new Error(`HTTP error for project ${projectId}! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(apiResponse => {
                        console.log(`Project ${projectId} API response:`, apiResponse);
                        
                        // Check if the response is successful and has data
                        if (!apiResponse.success) {
                            console.warn(`Project ${projectId} API response not successful:`, apiResponse);
                            return null;
                        }
                        
                        if (!apiResponse.data) {
                            console.log(`Project ${projectId} has no data field, skipping`);
                            return null;
                        }
                        
                        // Parse the raw JSON string from the API response
                        let geojsonData;
                        try {
                            geojsonData = JSON.parse(apiResponse.data);
                            console.log(`Project ${projectId} parsed GeoJSON:`, geojsonData);
                        } catch (parseError) {
                            console.error(`Failed to parse GeoJSON for project ${projectId}:`, parseError);
                            console.error(`Raw data was:`, apiResponse.data);
                            return null;
                        }
                        
                        // Check if the parsed GeoJSON is empty
                        if (!geojsonData) {
                            console.log(`Project ${projectId} has null GeoJSON, skipping`);
                            return null;
                        }
                        
                        if (!geojsonData.features) {
                            console.log(`Project ${projectId} has no features property, skipping`);
                            return null;
                        }
                        
                        if (geojsonData.features.length === 0) {
                            console.log(`Project ${projectId} has empty features array, skipping`);
                            return null;
                        }
                        
                        console.log(`âœ… Project ${projectId} GeoJSON data loaded successfully!`);
                        console.log(`   Features: ${geojsonData.features.length}`);
                        console.log(`   Feature types:`, geojsonData.features.map(f => f.geometry?.type).filter(Boolean));
                        
                        return { 
                            data: geojsonData, 
                            index, 
                            projectId,
                            projectName: projects.find(p => p.id === projectId)?.name || `Project ${projectId}`
                        };
                    })
                    .catch(error => {
                        console.error(`Error fetching GeoJSON for project ${projectId}:`, error);
                        return null; // Return null for failed requests
                    });
            });

            // Wait for all project GeoJSON data to load
            Promise.all(fetchPromises)
                .then(results => {
                    console.log('ðŸ” Promise.all results:', results);
                    console.log(`ðŸ“Š Total API calls: ${results.length}`);
                    console.log(`âŒ Null results: ${results.filter(r => r === null).length}`);
                    
                    // Filter out null results (projects with no/invalid GeoJSON data)
                    const validResults = results.filter(result => result !== null);
                    console.log(`âœ… Valid results: ${validResults.length}`);
                    
                    if (validResults.length === 0) {
                        console.log('âŒ No projects have valid GeoJSON data, staying at world view');
                        return;
                    }
                    
                    console.log('ðŸ“‹ Projects to be processed:');
                    validResults.forEach((result, idx) => {
                        console.log(`  ${idx + 1}. ${result.projectName} (${result.projectId}) - ${result.data.features.length} features`);
                    });
                    
                    const firstDatasetBounds = new mapboxgl.LngLatBounds();
                    
                    // Function to extend bounds with coordinates
                    function extendBounds(coords, bounds) {
                        if (typeof coords[0] === 'number') {
                            // This is a [lng, lat] coordinate
                            bounds.extend(coords);
                        } else if (Array.isArray(coords[0])) {
                            // This is an array of coordinates
                            coords.forEach(coord => extendBounds(coord, bounds));
                        }
                    }

                    // Process each project's GeoJSON data
                    validResults.forEach(({ data, index, projectId, projectName }, resultIndex) => {
                        const sourceId = `project-geojson-${projectId}`;
                        const color = colors[resultIndex % colors.length];
                        
                        console.log(`ðŸŽ¨ Processing project ${resultIndex + 1}/${validResults.length}: "${projectName}" (${projectId}) with color ${color}`);
                        
                        // Calculate and log bounds for this project
                        const projectBounds = new mapboxgl.LngLatBounds();
                        data.features.forEach(feature => {
                            if (feature.geometry && feature.geometry.coordinates) {
                                extendBounds(feature.geometry.coordinates, projectBounds);
                            }
                        });
                        
                        if (!projectBounds.isEmpty()) {
                            const sw = projectBounds.getSouthWest();
                            const ne = projectBounds.getNorthEast();
                            console.log(`ðŸ“ "${projectName}" bounds: SW[${sw.lng.toFixed(6)}, ${sw.lat.toFixed(6)}] to NE[${ne.lng.toFixed(6)}, ${ne.lat.toFixed(6)}]`);
                        }
                        
                        // Add the GeoJSON source
                        map.addSource(sourceId, {
                            type: 'geojson',
                            data: data
                        });
                        
                        console.log(`âœ… Added source: ${sourceId}`);

                        // Determine geometry types for this project
                        const geometryTypes = new Set();
                        if (data.features) {
                            data.features.forEach(feature => {
                                if (feature.geometry) {
                                    geometryTypes.add(feature.geometry.type);
                                    // Only extend bounds for the FIRST valid project (resultIndex 0)
                                    if (resultIndex === 0 && feature.geometry.coordinates) {
                                        extendBounds(feature.geometry.coordinates, firstDatasetBounds);
                                    }
                                }
                            });
                        }
                        
                        console.log(`Project "${projectName}" geometry types:`, Array.from(geometryTypes));

                        let layersAdded = 0;
                        
                        // Add layers based on geometry types
                        if (geometryTypes.has('Polygon') || geometryTypes.has('MultiPolygon')) {
                            const fillLayerId = `project-fill-${projectId}`;
                            const strokeLayerId = `project-stroke-${projectId}`;
                            
                            // Add fill layer for polygons
                            map.addLayer({
                                id: fillLayerId,
                                type: 'fill',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'fill-color': color,
                                    'fill-opacity': 0.6
                                }
                            });
                            console.log(`Added fill layer: ${fillLayerId} for project "${projectName}" with color ${color}`);
                            layersAdded++;

                            // Add stroke for polygons
                            map.addLayer({
                                id: strokeLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'Polygon'],
                                layout: {},
                                paint: {
                                    'line-color': '#000',
                                    'line-width': 2
                                }
                            });
                            console.log(`Added stroke layer: ${strokeLayerId} for project "${projectName}"`);
                            layersAdded++;
                        }

                        if (geometryTypes.has('LineString') || geometryTypes.has('MultiLineString')) {
                            const lineLayerId = `project-line-${projectId}`;
                            
                            // Add line layer with varying width for better visibility
                            const lineWidth = 3 + (resultIndex * 2); // First project: 3px, second: 5px, etc.
                            
                            map.addLayer({
                                id: lineLayerId,
                                type: 'line',
                                source: sourceId,
                                filter: ['in', '$type', 'LineString'],
                                layout: {},
                                paint: {
                                    'line-color': color,
                                    'line-width': lineWidth,
                                    'line-opacity': 0.8
                                }
                            });
                            console.log(`Added line layer: ${lineLayerId} for project "${projectName}" with color ${color} and width ${lineWidth}px`);
                            layersAdded++;
                        }

                        if (geometryTypes.has('Point') || geometryTypes.has('MultiPoint')) {
                            const pointLayerId = `project-points-${projectId}`;
                            
                            // Add circle layer for points
                            map.addLayer({
                                id: pointLayerId,
                                type: 'circle',
                                source: sourceId,
                                filter: ['in', '$type', 'Point'],
                                layout: {},
                                paint: {
                                    'circle-color': color,
                                    'circle-radius': 6,
                                    'circle-stroke-color': '#ffffff',
                                    'circle-stroke-width': 2
                                }
                            });
                            console.log(`Added points layer: ${pointLayerId} for project "${projectName}" with color ${color}`);
                            layersAdded++;
                        }
                        
                        console.log(`ðŸŽ¯ Total layers added for "${projectName}": ${layersAdded}`);
                    });

                    // Summary of what was loaded
                    console.log(`SUMMARY: Successfully loaded GeoJSON data for ${validResults.length} out of ${projectIds.length} projects:`);
                    validResults.forEach(({ data, projectId, projectName }) => {
                        const featureCount = data.features ? data.features.length : 0;
                        console.log(`  Project "${projectName}" (${projectId}): ${featureCount} features`);
                    });

                    // Fit the map to the FIRST project bounds only with smooth animation
                    if (!firstDatasetBounds.isEmpty()) {
                        console.log('Fitting map to first project bounds:', firstDatasetBounds);
                        console.log(`Zooming to: ${validResults[0].projectName} (${validResults[0].projectId})`);
                        map.fitBounds(firstDatasetBounds, {
                            padding: 200, // Increased padding for wider view
                            maxZoom: 11,  // Limit zoom to show ~100kmÂ² area (zoom 11 â‰ˆ 10km x 10km area)
                            duration: 6000, // 6 second smooth animation (very cinematic)
                            essential: true // Animation will complete even if user interacts
                        });
                    } else {
                        console.log('No valid bounds found in first project, staying at world view');
                        // Keep the world view if no valid data
                    }
                })
                .catch(error => {
                    console.error('Error loading project GeoJSON data:', error);
                    alert('Error loading project GeoJSON data. Check the console for details.');
                    // Fallback to a default view if GeoJSON fails to load
                    map.setCenter([0, 0]);
                    map.setZoom(2);
                });
        });
    }
</script>
{% endblock inline_extra_js %}
